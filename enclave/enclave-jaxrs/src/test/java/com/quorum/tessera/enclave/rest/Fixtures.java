package com.quorum.tessera.enclave.rest;

import static java.util.Collections.singletonList;
import static java.util.Collections.singletonMap;

import com.quorum.tessera.enclave.EncodedPayload;
import com.quorum.tessera.enclave.PrivacyMode;
import com.quorum.tessera.enclave.TxHash;
import com.quorum.tessera.encryption.PublicKey;

public class Fixtures {

  static EncodedPayload createSample() {

    final byte[] sender =
        new byte[] {
          5, 66, -34, 71, -62, 114, 81, 104, 98, -70, -32, -116, 83, -15, -53, 3, 68, 57, -89, 57,
          24, 79, -25, 7, 32, -115, -39, 40, 23, -78, -36, 26
        };
    final byte[] cipherText =
        new byte[] {
          -46, -26, -18, 127, 37, -2, -84, -56, -71, 26, 3, 102, -61, 38, -1, 37, 105, 2, 10, 86, 6,
          117, 69, 73, 91, 81, 68, 106, 23, 74, 12, 104, -63, 63, -119, 95, -16, -82, -34, 101, 89,
          38, -19, 8, 23, -70, 90, 5, -7, -15, 23, -8, -88, 47, 72, 105, -103, -34, 10, 109, -48,
          114, -127, -38, 41, 12, 3, 72, 113, -56, -90, -70, 124, -25, 127, 60, 100, 95, 127, 31,
          -72, -101, 26, -12, -9, 108, 54, 2, 124, 22, 55, 9, 123, 54, -16, 51, 28, -25, -102, -100,
          -23, 89, -15, 86, 22, -100, -63, -110, -2, -32, -1, 12, -116, 102, -43, 92, 2, 105, -78,
          -73, 111, -123, -59, -118, -32, 47, -63, 41, 72, -72, 35, -68, 45, 77, 110, -24, -113,
          -106, -31, -42, 13, -123, 54, 45, 83, -38, -57, 116, 107, -84, 22, -30, -49, 84, 39, 17,
          -20, -75, -122, -6, 73, -61, 70, -53, -65, -22, 13, 23, 43, -101, 23, 16, 31, -1, -19, -8,
          -94, -119, -28, -127, -101, 43, 31, -28, 16, -78, -86, 47, 42, 21, 115, 127, -81, 44, -33,
          -12, -74, -77, 111, 0, 121, 70, 67, 81, 74, 90, 116, -14, -75, 82, -110, -119, -23, 84,
          74, 61, -31, -66, -71, -106, 60, 127, -113, -26, 73, -50, -112, -45, 82, 37, -68, -49, 40,
          -73, -53, 85, -71, 82, 32, 117, 25, -81, -13, -30, -48, -118, -82, 125, -63, 1, -46, -115,
          -104, 32, 2, -1, -124, -88, -20, -77, 108, 123, 41, 78, 108, -88, 65, 84, 66, -40, 79,
          -118, 63, -109, -85, -52, 8, -97, -49, 87, -27, -63, 75, -45, 51, 7, 116, -68, 16, 89, 53,
          14, -121, 53, 38, -16, 122, -47, -110, -19, 72, 102, -81, 13, 13, -28, -103, 39, -26, 36,
          -15, -61, -91, -64, -99, 118, -34, -45, -119, 33, 57, 92, 119, 95, -17, 19, 50, 46, -119,
          88, -123, -49, -68, -105, 74, -15, 102, 74, -19, 29, 75, -114, -34, -54, -6, 111, 122, 2,
          55, 99, 58, -31, 123, 50, -84, -128, 71, 79, 19, -40, 92, 7, 75, -31, -113, -60, -8, 121,
          105, 91, -127, 69, 106, -49, -13, -91, -34
        };
    final byte[] nonce =
        new byte[] {
          -114, -128, 47, 49, 6, -71, -111, -76, -100, -16, 113, -126, 3, 107, 55, 1, 43, -6, -43,
          -104, -128, -125, -37, 31
        };
    final byte[] recipientBox =
        new byte[] {
          -111, -41, -32, 59, -89, -69, -51, -27, 64, 74, -89, -63, -97, 54, 12, -10, -104, 111,
              -100, -98, 4,
          34, 67, 73, -57, -46, 15, 100, -21, -42, -14, -43, 72, 64, -127, -44, 113, -10, 82, 105,
              -81, 122,
          61, -50, 28, 108, -56, -92
        };
    final byte[] recipientNonce =
        new byte[] {
          -110, 45, 44, -76, 17, 23, -76, 0, -75, 112, 70, 97, 108, -70, -76, 32, 100, -46, -67,
          107, -89, 98, 64, -85
        };
    final byte[] recipientKey =
        new byte[] {
          68, -32, 25, 5, 107, 82, 105, -52, 87, 66, -77, -98, -36, 81, -128, -88, -112, -14, 38,
          49, 94, 61, 30, 92, 123, -124, -46, 35, 57, -119, -48, 23
        };

    return EncodedPayload.Builder.create()
        .withSenderKey(PublicKey.from(sender))
        .withCipherText(cipherText)
        .withCipherTextNonce(nonce)
        .withRecipientBoxes(singletonList(recipientBox))
        .withRecipientNonce(recipientNonce)
        .withRecipientKeys(singletonList(PublicKey.from(recipientKey)))
        .withPrivacyMode(PrivacyMode.PARTY_PROTECTION)
        .withAffectedContractTransactions(
            singletonMap(new TxHash("test".getBytes()), "test".getBytes()))
        .withExecHash(new byte[0])
        .build();
  }
}
